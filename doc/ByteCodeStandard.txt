对于所有的指令，第一个字节都是操作码，以下的定义都只讲参数格式。

下面标准将采用下面的格式定义：
指令1, 指令2, ..., 指令n 的参数格式为：
	#总体的声明（注释）
	参数1：解释；（x字节）
	参数2：解释；（x字节）
	...
	参数n：解释；（x字节）

* 值得注意的是，接下来的文档会涉及到一些代码中的定义，建议阅读完mem.h和cpu.h后再阅读文档

add, sub, mul, div, and, or, shl, shr 的参数格式为：
	#每个指令都有两个操作数，设第一个操作数为n1，第二个操作数为n2
	目标寄存器标号：将n1和n2进行相应运算后，把结果存入目标寄存器；（2字节）
	n1类型：reg_type或num_type；（1字节）
	n1操作数：寄存器标号或立即数；（2字节）
	n2类型：reg_type或num_type；（1字节）
	n2操作数：寄存器标号或立即数；（2字节）

not 的参数格式为：
	# 给寄存器取反
	寄存器标号：需要取反的寄存器标号；（2字节）

mov, ld, ldi, st, sti 的参数格式为：
	#这些指令比较复杂，所以只介绍参数
	目标数：目标数可能是寄存器标号或者以寄存器标号为址的内存；（2字节）
	源数类型：reg_type或num_type；（1字节）
	源数：较为复杂，暂不介绍，具体请见代码；（2字节）

push 的参数格式为：
	#将指定的寄存器压入栈
	源数：要压入的寄存器标号；（2字节）

pop 的参数格式为：
	#弹出栈到指定的寄存器或者直接弹出，不存入寄存器

	目标数类型：reg_type代表要弹出到寄存器，num_type代表直接弹出；（1字节）
	目标数：如果目标数类型为reg_type，则目标数为要弹出的寄存器标号。如果目标数类型为num_type，则目标数无意义；（2字节）

cmp 的参数格式为：
	#比较两个值，两个值都可以分别为寄存器或立即数。比较后将比较结果存入R_COND（详细见代码）。这里我们设要比较的两个值分别为n1和n2
	n1类型：reg_type或num_type；（1字节）
	n1操作数：寄存器标号或立即数；（2字节）
	n2类型：reg_type或num_type；（1字节）
	n2操作数：寄存器标号或立即数；（2字节）

br 的参数格式为：
	#条件跳转指令
	条件代码：用于与R_COND对比，详细见代码；（2字节）
	目标地址：如果条件代码与R_COND对比成功，则跳转到目标地址；（4字节）

jmp 的参数格式为：
	#无条件跳转指令
	目标地址：直接跳转到目标地址；（4字节）

call 的参数格式为：
	#调用函数
	目标地址：调用目标地址；（4字节）

ret 无参数

in, out 的参数格式为：
	#给定两个寄存器，分别为端口号和参数，调用IO
	端口号：端口寄存器标号；（2字节）
	参数：参数寄存器标号；（2字节）
